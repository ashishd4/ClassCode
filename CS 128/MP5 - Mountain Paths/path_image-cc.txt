#include "path_image.hpp"

#include <fstream>
#include <iostream>

int PathDefiner(int up, int str, int down) {
  if (up < str && up < down) {
    return -1;
  }

  if (down < str) {
    return 1;
  }

  return 0;
}

PathImage::PathImage(const GrayscaleImage& image, const ElevationDataset& dataset): width_(dataset.Width()), height_(dataset.Height()) {
  for (unsigned int i = 0; i < height_; i++) {
    Path route = Path(width_, i);
    paths_.push_back(route);
  }

  int diff_str = 0, diff_up = 0, diff_down = 0, elevation = 0;
  unsigned int row = 0;

  for (unsigned int i = 0; i < height_; i++) {  // nested for loops are complicated, but they essentially create the paths and find the green path
    row = i;
    elevation = dataset.DatumAt(0, i);

    for (unsigned int j = 1; j < width_; j++) {
      diff_str = abs(dataset.DatumAt(j, row) - elevation);
      diff_up = INT16_MAX;
      diff_down = INT16_MAX;

      if (row != 0) { diff_up = abs(dataset.DatumAt(j, row - 1) - elevation); }
      if (row != height_ - 1) { diff_down = abs(dataset.DatumAt(j, row + 1) - elevation); }

      paths_[i].SetLoc(j, paths_[i].GetPath()[j - 1] + PathDefiner(diff_up, diff_str, diff_down));
      row += PathDefiner(diff_up, diff_str, diff_down);

      if (PathDefiner(diff_up, diff_str, diff_down) == -1) {
        paths_[i].IncEleChange(diff_up);
      } else if (PathDefiner(diff_up, diff_str, diff_down) == 0) {
        paths_[i].IncEleChange(diff_str);
      } else {
        paths_[i].IncEleChange(diff_down);
      }
      
      elevation = dataset.DatumAt(j, row);
    }
  }
  path_image_ = image.GetImage();
  for (unsigned int i = 0; i < height_; i++) {
    for (unsigned int j = 0; j < width_; j++) { 
      path_image_[paths_[i].GetPath()[j]][j] = Color(kRedR, kRedG, kRedB); 
    }  // making red paths
  }

  unsigned int smallest = 0;
  
  for (unsigned int i = 1; i < height_; i++) {
    if (paths_[i].EleChange() < paths_[smallest].EleChange()) { smallest = i; }
  }

  for (unsigned int j = 0; j < width_; j++) { 
    path_image_[paths_[smallest].GetPath()[j]][j] = Color(kGreenR, kGreenG, kGreenB); 
  }  // making the green path
}

size_t PathImage::Width() const { return width_; }
size_t PathImage::Height() const { return height_; }

unsigned int PathImage::MaxColorValue() const { return kMaxColorValue; }

const vector<Path>& PathImage::Paths() const { return paths_; }

const vector<vector<Color>>& PathImage::GetPathImage() const {
  return path_image_;
}

void PathImage::ToPpm(const string& name) const {
  ofstream ofs(name);
  ofs << "P3" << endl;
  ofs << width_ << " " << height_ << endl;
  ofs << kMaxColorValue << endl;

  for (unsigned int i = 0; i < height_; i++) {
    for (unsigned int j = 0; j < width_; j++) {
      Color checker = path_image_[i][j];
      ofs << checker.Red() << " " << checker.Green() << " " << checker.Blue()
          << " ";
    }
    ofs << endl;
  }
}
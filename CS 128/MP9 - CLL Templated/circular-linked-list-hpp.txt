#ifndef CIRCULAR_LINKED_LIST_HPP
#define CIRCULAR_LINKED_LIST_HPP

#include <iostream>

#include "node.hpp"

enum class Order { kASC, kDESC };

template <typename T>
class CircularLinkedList {
public:
  CircularLinkedList() = default;  // 1 - default constructor
  CircularLinkedList(const CircularLinkedList<T>& source);
  CircularLinkedList<T>& operator=(const CircularLinkedList<T>& source);
  ~CircularLinkedList();
  void Clear();  // helper function

  void InsertInOrder(const T& data);
  void InsertAsc(const T& data); // helper for InsertInOrder
  void InsertDesc(const T& data); // helper for InsertInOrder
  void Reverse();

  template <typename U>
  friend std::ostream& operator<<(std::ostream& os,
                                  const CircularLinkedList<U>& cll);

private:
  Node<T>* head_ = nullptr;
  Node<T>* tail_ = nullptr;
  Order node_order_ = Order::kASC;
};

template <typename T>
std::ostream& operator<<(std::ostream& os, const CircularLinkedList<T>& cll) {
  Node<T>* iter = cll.head_;
  // empty list condition
  if (iter == nullptr) {
    os << "Empty list";
    return os;
  }
  // non-empty list condition
  do {
    os << iter->data << '\t';
    iter = iter->next;
  } while (iter != cll.head_);

  return os;
}

template <typename T>  // 2 - copy constructor
CircularLinkedList<T>::CircularLinkedList(const CircularLinkedList<T>& source):
    node_order_(source.node_order_) {
  if (source.head_ == nullptr) {
    head_ = nullptr;
    tail_ = nullptr;
    return;
  }
  Node<T>* walker = source.head_;
  Node<T>* first = new Node(walker->data);
  head_ = first;

  Node<T>* temp = head_;
  walker = walker->next;
  while (walker != source.head_) {
    temp->next = new Node(walker->data);
    temp = temp->next;
    walker = walker->next;
  }

  tail_ = temp;
  tail_->next = head_;
}

template <typename T>
void CircularLinkedList<T>::Clear() {
  if (head_ == nullptr) {  // if no nodes
    return;
  }

  if (head_ == tail_) {  // if one node
    delete head_;
    return;
  }

  if (head_->next == tail_) {  // if two nodes
    delete head_;
    delete tail_;
    return;
  }

  Node<T>* travel = head_->next;
  Node<T>* guide = travel->next;

  while (guide != head_ && travel != head_) {
    delete travel;
    travel = guide;
    guide = guide->next;
  }

  delete head_;
  delete tail_;
}

template <typename T>  // 3 - copy assignment operator
CircularLinkedList<T>& CircularLinkedList<T>::operator=(
    const CircularLinkedList<T>& source) {
  if (this == &source) {
    return *this;
  }

  Clear();
  node_order_ = source.node_order_;

  if (source.head_ == nullptr) {
    head_ = nullptr;
    tail_ = nullptr;
    return *this;
  }
  Node<T>* walker = source.head_;
  Node<T>* first = new Node(walker->data);
  head_ = first;

  Node<T>* temp = head_;
  walker = walker->next;
  while (walker != source.head_) {
    temp->next = new Node(walker->data);
    temp = temp->next;
    walker = walker->next;
  }

  tail_ = temp;
  tail_->next = head_;

  return *this;
}

template <typename T>  // 5 - destructor
CircularLinkedList<T>::~CircularLinkedList() {
  Clear();
}

template <typename T>
void CircularLinkedList<T>::InsertAsc(const T& data) {
  Node<T>* add_this = new Node(data);

  if (data <= head_->data) { //=
    add_this->next = head_;
    head_ = add_this;
    tail_->next = head_;
  } else if (data >= tail_->data) { //=
    add_this->next = head_;
    tail_->next = add_this;
    tail_ = add_this;
  } else {
    Node<T>* iterate = head_;
    while (iterate->next->data < data) {
      iterate = iterate->next;
    }
    Node<T>* after = iterate->next;
    iterate->next = add_this;
    add_this->next = after;
  }
}

template <typename T>
void CircularLinkedList<T>::InsertDesc(const T& data) {
  Node<T>* add_this = new Node(data);

  if (add_this->data >= head_->data) {
    add_this->next = head_;
    head_ = add_this;
    tail_->next = head_;
  } else if (add_this->data <= tail_->data) {
    add_this->next = head_;
    tail_->next = add_this;
    tail_ = add_this;
  } else {
    Node<T>* iterate = head_;
    while (iterate->next->data > add_this->data) {
      iterate = iterate->next;
    }
    Node<T>* after = iterate->next;
    iterate->next = add_this;
    add_this->next = after;
  }
}

template <typename T>  // 4 - Insert In function
void CircularLinkedList<T>::InsertInOrder(const T& data) {
  if (head_ == nullptr) {
    head_ = new Node<T>(data);
    tail_ = head_;
    head_->next = tail_;
    return;
  }

  if (node_order_ == Order::kASC) {
    InsertAsc(data);
  } else {
    InsertDesc(data);
  }
}

template <typename T>  // 6 - Reverse function
void CircularLinkedList<T>::Reverse() {
  if (node_order_ == Order::kASC) {
    node_order_ = Order::kDESC;
  } else {
    node_order_ = Order::kASC;
  }

  if (head_ == nullptr || tail_ == head_) {
    return;
  }

  Node<T>* jumper = head_;
  Node<T>* amigo = head_->next;
  Node<T>* follow = amigo->next;

  head_->next = tail_;

  while (follow != head_) {
    amigo->next = jumper;
    jumper = amigo;
    amigo = follow;
    follow = follow->next;
  }
  amigo->next = jumper;

  head_ = amigo;
  tail_ = follow;
}

#endif
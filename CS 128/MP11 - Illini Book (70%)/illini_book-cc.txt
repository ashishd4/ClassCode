#include "illini_book.hpp"

#include <fstream>

#include "utilities.hpp"


using namespace std;

// Your code here!

int IlliniBook::DistanceHelper(int one, int two) const {
  if (one == two) {
    return 0;
  }
  queue<int> line;
  map<int, int> uin_dist;
  set<int> visited = {one};
  int top = 0;

  for (auto const& [key, val] : ships_.at(one)) {
    if (key == two) { return 1; }
    line.push(key);
    uin_dist.insert({key, 1});
  }

  while (!line.empty()) {
    if (line.front() == two) {
      return uin_dist.at(line.front());
    }

    top = line.front();
    line.pop();

    if (visited.contains(top)) {
      continue;
    }

    visited.insert(top);
    for (auto const& [key, val] : ships_.at(top)) {
      if (key == two && !visited.contains(top)) {
        return uin_dist.at(top) + 1;
      }
      line.push(key);
      uin_dist.insert({key, uin_dist.at(top) + 1});
    }
  }
  return -1;
}

int IlliniBook::DistanceRelHelper(int one, int two, const string& the_ship) const {
  if (one == two) { return 0; }

  queue<int> line;
  map<int, int> uin_dist;
  set<int> visited = {one};
  int top = 0;

  for (auto const& [key, val] : ships_.at(one)) {
    if (val == the_ship) {
      if (key == two) { return 1; }
      line.push(key);
      uin_dist.insert({key, 1});
    }
  }

  while (!line.empty()) {
    if (line.front() == two) {
      return uin_dist.at(line.front());
    }

    top = line.front();
    line.pop();

    if (visited.contains(top)) { continue; }

    visited.insert(top);
    for (auto const& [key, val] : ships_.at(top)) {
      if (val == the_ship) {
        if (key == two && !visited.contains(top)) {
          return uin_dist.at(top) + 1;
        }
        line.push(key);
        uin_dist.insert({key, uin_dist.at(top) + 1});
      }
    }
  }
  return -1;
}

int IlliniBook::DistanceRelsHelper(int one, int two, const set<string>& the_ships) const {
  if (one == two) { return 0; }

  queue<int> line;
  map<int, int> uin_dist;
  set<int> visited = {one};
  int top = 0;

  for (auto const& [key, val] : ships_.at(one)) {
    if (the_ships.contains(val)) {
      if (key == two) { return 1; }
      line.push(key);
      uin_dist.insert({key, 1});
    }
  }

  while (!line.empty()) {
    if (line.front() == two) {
      return uin_dist.at(line.front());
    }

    top = line.front();
    line.pop();

    if (visited.contains(top)) { continue; }

    visited.insert(top);
    for (auto const& [key, val] : ships_.at(top)) {
      if (the_ships.contains(val)) {
        if (key == two && !visited.contains(top)) {
          return uin_dist.at(top) + 1;
        }
        line.push(key);
        uin_dist.insert({key, uin_dist.at(top) + 1});
      }
    }
  }
  return -1;
}

map<int, int> IlliniBook::Distances(int uin) {
  map<int, int> distances_map;

  for (auto const& [key, val] : ships_.at(uin)) {
    distances_map.insert(pair<int, int>(key, DistanceHelper(uin, key)));
  }

  return distances_map;
}

void IlliniBook::ConstHelper(int pers1, const std::string& ship, int pers2) {
  map<int, string> inner_map;

  if (ships_.contains(pers1)) {
    inner_map = ships_.at(pers1);
  }

  inner_map.insert(pair<int, string>(pers2, ship));
  ships_.erase(pers1);
  ships_.insert(pair<int, map<int, string>>(pers1, inner_map));
}

IlliniBook::IlliniBook(const std::string& people_fpath, const std::string& relations_fpath) {
  int number = 0;
  string filler;
  vector<string> placers;

  ifstream ifs(people_fpath);
  ifstream ifs2(relations_fpath);

  while (ifs >> number) {
    // cout << number << endl;
    uins_.push_back(number);
  }

  while (ifs2 >> filler) {
    placers = utilities::Split(filler, ',');

    ConstHelper(stoi(placers[0]), placers[2], stoi(placers[1]));
    ConstHelper(stoi(placers[1]), placers[2], stoi(placers[0]));
  }

  map<int, string> clear_map;

  for (unsigned int i = 0; i < uins_.size(); i++) {
    if (!ships_.contains(uins_[i])) {
      ships_.insert(pair<int, map<int, string>>(uins_[i], clear_map));
    }
  }
}

bool IlliniBook::AreRelated(int uin_1, int uin_2) const {
  return (DistanceHelper(uin_1, uin_2) != -1);
}

bool IlliniBook::AreRelated(int uin_1, int uin_2, const string& relationship) const {
  return (DistanceRelHelper(uin_1, uin_2, relationship) != -1);
}

int IlliniBook::GetRelated(int uin_1, int uin_2) const {  // does not work bc BFS needed
  return DistanceHelper(uin_1, uin_2);
}

int IlliniBook::GetRelated(int uin_1, int uin_2, const std::string& relationship) const {
  return DistanceRelHelper(uin_1, uin_2, relationship);
}

vector<int> IlliniBook::GetSteps(int uin, int n) const {
  vector<int> answer;

  answer.push_back(uin);
  answer.push_back(n);

  // for (int node : uins_) {
  //   if (DistanceHelper(uin, node) == n) {
  //     answer.push_back(node);
  //   }
  // }

  return answer;
}

size_t IlliniBook::CountGroups() const { 
  set<int> found;
  size_t groups = 0;
  int i = uins_[0];
  int j = 0;

  while (found.size() != uins_.size()) {
    groups++;
    for (int num : uins_) {
      if (!found.contains(num)) {
        if (DistanceHelper(num, i) != -1) {
          found.insert(num);
          if (found.size() == uins_.size()) {
            break;
          }
        } else {
          j = num;
        }
      }
    }

    i = j;
  }

  return groups; 
}

size_t IlliniBook::CountGroups(const std::string& relationship) const {
  set<int> found;
  size_t groups = 0;
  int i = uins_[0];
  int j = 0;

  while (found.size() != uins_.size()) {
    groups++;
    for (int num : uins_) {
      if (!found.contains(num)) {
        if (DistanceRelHelper(num, i, relationship) != -1) {
          found.insert(num);
          if (found.size() == uins_.size()) {
            break;
          }
        } else {
          j = num;
        }
      }
    }

    i = j;
  }

  return groups; 
}

size_t IlliniBook::CountGroups(const std::vector<std::string>& relationships) const {
  set<int> found;
  size_t groups = 0;
  int i = uins_[0];
  int j = 0;

  set<string> ships;

  for (const string& add : relationships) {
    ships.insert(add);
  }

  while (found.size() != uins_.size()) {
    groups++;
    for (int num : uins_) {
      if (!found.contains(num)) {
        if (DistanceRelsHelper(num, i, ships) != -1) {
          found.insert(num);
          if (found.size() == uins_.size()) {
            break;
          }
        } else {
          j = num;
        }
      }
    }

    i = j;
  }

  return groups; 
}